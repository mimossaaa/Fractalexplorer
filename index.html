<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Fractals</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for canvas container and controls */
        #canvas-container {
            position: relative;
            width: 100%;
            max-width: 900px; /* Limit max width */
            margin: 20px auto; /* Center the container */
            border-radius: 8px; /* Rounded corners */
            overflow: hidden; /* Hide overflow */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Add shadow */
            background-color: #000; /* Black background for fractals */
        }

        canvas {
            display: block; /* Remove extra space below canvas */
            width: 100%;
            height: 500px; /* Give canvas a fixed height for visibility */
            background-color: #000; /* Black background for fractals */
        }

        .controls {
            padding: 15px;
            background-color: #f3f4f6; /* Light gray background */
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
            display: flex;
            flex-wrap: wrap; /* Allow controls to wrap on small screens */
            gap: 15px; /* Space between controls */
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #374151; /* Dark gray text */
        }

        .control-group input[type="number"],
        .control-group input[type="range"],
        .control-group input[type="text"] {
            padding: 8px;
            border: 1px solid #d1d5db; /* Light border */
            border-radius: 4px;
            font-size: 1rem;
        }

        .control-group input[type="range"] {
            width: 150px; /* Fixed width for sliders */
        }

        button {
             padding: 10px 15px;
             background-color: #3b82f6; /* Blue background */
             color: white;
             border: none;
             border-radius: 5px;
             cursor: pointer;
             font-size: 1rem;
             transition: background-color 0.3s ease;
             box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Add shadow */
         }

         button:hover {
             background-color: #2563eb; /* Darker blue on hover */
         }

         /* Hide fractal divs by default */
         .fractal-content {
             display: none;
         }

         /* Show the active fractal div */
         .fractal-content.active {
             display: block;
         }

         /* Navigation styling */
         nav a {
             padding: 10px 15px;
             margin: 0 5px;
             color: #3b82f6; /* Blue text */
             text-decoration: none;
             font-weight: bold;
             border-radius: 5px;
             transition: background-color 0.3s ease;
         }

         nav a:hover {
             background-color: #eff6ff; /* Light blue background on hover */
         }

         nav a.active {
             background-color: #3b82f6;
             color: white;
         }
    </style>
</head>
<body class="bg-gray-100 font-sans leading-normal tracking-normal">

    <header class="bg-white shadow-md py-4">
        <div class="container mx-auto px-6">
            <h1 class="text-2xl font-bold text-center text-gray-800">Interactive Fractals</h1>
        </div>
    </header>

    <nav class="bg-gray-200 py-3 shadow-sm">
        <div class="container mx-auto px-6 flex justify-center flex-wrap">
            <a href="#koch" class="nav-link active" data-fractal="koch">Koch Snowflake</a>
            <a href="#fern" class="nav-link" data-fractal="fern">Barnsley Fern</a>
            <a href="#sierpinski" class="nav-link" data-fractal="sierpinski">Sierpinski Triangle</a>
            <a href="#hilbert" class="nav-link" data-fractal="hilbert">Hilbert Curve</a>
            <a href="#dragon" class="nav-link" data-fractal="dragon">Dragon Curve</a>
        </div>
    </nav>

    <main class="container mx-auto px-6 py-8">

        <div id="canvas-container">
            <canvas id="fractalCanvas"></canvas>
            <div id="controls" class="controls">
                </div>
        </div>

        <div id="koch-content" class="fractal-content active"></div>
        <div id="fern-content" class="fractal-content"></div>
        <div id="sierpinski-content" class="fractal-content"></div>
        <div id="hilbert-content" class="fractal-content"></div>
        <div id="dragon-content" class="fractal-content"></div>

    </main>

    <footer class="bg-gray-800 text-white text-center py-4 mt-8">
        <p>&copy; 2023 Interactive Fractals</p>
    </footer>

    <script>
        const canvas = document.getElementById('fractalCanvas');
        const ctx = canvas.getContext('2d');
        const controlsDiv = document.getElementById('controls');
        const navLinks = document.querySelectorAll('.nav-link');
        const fractalContentDivs = document.querySelectorAll('.fractal-content');

        let currentFractal = 'koch'; // Default fractal
        let animationFrameId = null; // To manage animation loops

        // Canvas dimensions (will be set dynamically)
        let canvasWidth;
        let canvasHeight;

        // Pan and Zoom variables (simplified for line fractals)
        let translateX = 0;
        let translateY = 0;
        let globalScale = 1; // Use a single global scale for simpler fractals
        let isDragging = false;
        let dragStartX, dragStartY;

        // --- Fractal Specific Parameters ---

        // Koch Snowflake
        let kochGenerations = 4;

        // Barnsley Fern
        let fernPoints = [];
        let fernCurrentX = 0;
        let fernCurrentY = 0;
        let fernIterationsPerFrame = 1000; // Number of points to draw per frame
        let fernTotalPoints = 0; // Total points drawn
        let fernMaxPoints = 50000; // Max points for fern
        let fernAnimating = false;

        // Sierpinski Triangle
        let sierpinskiPoints = [];
        let sierpinskiVertices = [{x: 0, y: 0}, {x: 1, y: 0}, {x: 0.5, y: Math.sqrt(3)/2}];
        let sierpinskiCurrentPoint = {x: 0.25, y: 0.25};
        let sierpinskiIterationsPerFrame = 1000; // Number of points to draw per frame
        let sierpinskiTotalPoints = 0;
        let sierpinskiMaxPoints = 50000;
        let sierpinskiAnimating = false;

        // Hilbert Curve
        let hilbertGenerations = 4;
        let hilbertAnimating = false;
        let hilbertAnimationStep = 0;
        let hilbertString = "";
        let hilbertRules = {"A": "+BF-AFA-FB+", "B": "-AF+BFB+FA-"};
        let hilbertAxiom = "A";
        let hilbertAngle = 90; // Angle in degrees

        // Dragon Curve
        let dragonGenerations = 10;
        let dragonAnimating = false;
        let dragonAnimationStep = 0;
        let dragonString = "";
        let dragonRules = {"X": "X+YF+", "Y": "-FX-Y"};
        let dragonAxiom = "FX";
        let dragonAngle = 90; // Angle in degrees


        // --- Helper Functions ---

        // Function to set canvas size and update dimensions
        function setCanvasSize() {
            canvasWidth = canvas.offsetWidth;
            canvasHeight = canvas.offsetHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            // Redraw after resize
            drawFractal();
        }

        // Function to generate controls for a fractal
        function generateControls(fractalType) {
            controlsDiv.innerHTML = ''; // Clear existing controls

            const createControlGroup = (labelText, inputHtml) => {
                const div = document.createElement('div');
                div.className = 'control-group';
                const label = document.createElement('label');
                label.textContent = labelText;
                div.appendChild(label);
                const input = document.createElement('div'); // Use a div to hold the input HTML
                input.innerHTML = inputHtml;
                div.appendChild(input.firstChild); // Append the actual input element
                return div;
            };

            switch (fractalType) {
                case 'koch':
                    controlsDiv.appendChild(createControlGroup('Generations:', `<input type="number" id="kochGenerations" value="${kochGenerations}" min="1" max="7">`));
                    break;
                case 'fern':
                    controlsDiv.appendChild(createControlGroup('Max Points:', `<input type="number" id="fernMaxPoints" value="${fernMaxPoints}" min="10000" max="500000">`));
                    const fernAnimateBtn = document.createElement('button');
                    fernAnimateBtn.textContent = fernAnimating ? 'Stop Animation' : 'Start Animation';
                    fernAnimateBtn.id = 'fernAnimateBtn';
                    controlsDiv.appendChild(fernAnimateBtn);
                    break;
                case 'sierpinski':
                     controlsDiv.appendChild(createControlGroup('Max Points:', `<input type="number" id="sierpinskiMaxPoints" value="${sierpinskiMaxPoints}" min="10000" max="500000">`));
                     const sierpinskiAnimateBtn = document.createElement('button');
                     sierpinskiAnimateBtn.textContent = sierpinskiAnimating ? 'Stop Animation' : 'Start Animation';
                     sierpinskiAnimateBtn.id = 'sierpinskiAnimateBtn';
                     controlsDiv.appendChild(sierpinskiAnimateBtn);
                    break;
                case 'hilbert':
                    controlsDiv.appendChild(createControlGroup('Generations:', `<input type="number" id="hilbertGenerations" value="${hilbertGenerations}" min="1" max="7">`));
                     const hilbertAnimateBtn = document.createElement('button');
                     hilbertAnimateBtn.textContent = hilbertAnimating ? 'Stop Drawing' : 'Start Drawing';
                     hilbertAnimateBtn.id = 'hilbertAnimateBtn';
                     controlsDiv.appendChild(hilbertAnimateBtn);
                    break;
                case 'dragon':
                    controlsDiv.appendChild(createControlGroup('Generations:', `<input type="number" id="dragonGenerations" value="${dragonGenerations}" min="1" max="15">`));
                     const dragonAnimateBtn = document.createElement('button');
                     dragonAnimateBtn.textContent = dragonAnimating ? 'Stop Drawing' : 'Start Drawing';
                     dragonAnimateBtn.id = 'dragonAnimateBtn';
                     controlsDiv.appendChild(dragonAnimateBtn);
                    break;
            }

            // Add event listeners to the new controls
            addControlEventListeners(fractalType);
        }

        // Function to add event listeners to controls
        function addControlEventListeners(fractalType) {
            switch (fractalType) {
                case 'koch':
                    document.getElementById('kochGenerations').addEventListener('change', (e) => {
                        kochGenerations = parseInt(e.target.value);
                        drawFractal();
                    });
                    break;
                case 'fern':
                    document.getElementById('fernMaxPoints').addEventListener('change', (e) => {
                        fernMaxPoints = parseInt(e.target.value);
                        // Reset and redraw if max points changed significantly
                        if (!fernAnimating) {
                             resetFern();
                             drawFractal();
                        }
                    });
                    document.getElementById('fernAnimateBtn').addEventListener('click', () => {
                        fernAnimating = !fernAnimating;
                        document.getElementById('fernAnimateBtn').textContent = fernAnimating ? 'Stop Animation' : 'Start Animation';
                        if (fernAnimating) {
                            resetFern(); // Start animation from scratch
                            animateFern();
                        } else {
                            cancelAnimationFrame(animationFrameId);
                        }
                    });
                    break;
                case 'sierpinski':
                     document.getElementById('sierpinskiMaxPoints').addEventListener('change', (e) => {
                         sierpinskiMaxPoints = parseInt(e.target.value);
                         if (!sierpinskiAnimating) {
                             resetSierpinski();
                             drawFractal();
                         }
                     });
                     document.getElementById('sierpinskiAnimateBtn').addEventListener('click', () => {
                         sierpinskiAnimating = !sierpinskiAnimating;
                         document.getElementById('sierpinskiAnimateBtn').textContent = sierpinskiAnimating ? 'Stop Animation' : 'Start Animation';
                         if (sierpinskiAnimating) {
                             resetSierpinski();
                             animateSierpinski();
                         } else {
                             cancelAnimationFrame(animationFrameId);
                         }
                     });
                    break;
                 case 'hilbert':
                    document.getElementById('hilbertGenerations').addEventListener('change', (e) => {
                        hilbertGenerations = parseInt(e.target.value);
                        generateLSystemString('hilbert'); // Regenerate string
                        hilbertAnimationStep = 0; // Reset animation
                        drawFractal(); // Draw the initial state or full generated string
                    });
                     document.getElementById('hilbertAnimateBtn').addEventListener('click', () => {
                         hilbertAnimating = !hilbertAnimating;
                         document.getElementById('hilbertAnimateBtn').textContent = hilbertAnimating ? 'Stop Drawing' : 'Start Drawing';
                         if (hilbertAnimating) {
                             hilbertAnimationStep = 0; // Start drawing from scratch
                             animateLSystem('hilbert');
                         } else {
                             cancelAnimationFrame(animationFrameId);
                         }
                    });
                    break;
                 case 'dragon':
                    document.getElementById('dragonGenerations').addEventListener('change', (e) => {
                        dragonGenerations = parseInt(e.target.value);
                        generateLSystemString('dragon'); // Regenerate string
                        dragonAnimationStep = 0; // Reset animation
                        drawFractal(); // Draw the initial state or full generated string
                    });
                     document.getElementById('dragonAnimateBtn').addEventListener('click', () => {
                         dragonAnimating = !dragonAnimating;
                         document.getElementById('dragonAnimateBtn').textContent = dragonAnimating ? 'Stop Drawing' : 'Start Drawing';
                         if (dragonAnimating) {
                             dragonAnimationStep = 0; // Start drawing from scratch
                             animateLSystem('dragon');
                         } else {
                             cancelAnimationFrame(animationFrameId);
                         }
                    });
                    break;
            }
        }


        // --- Drawing Functions for each Fractal ---

        function drawKochSnowflake() {
            cancelAnimationFrame(animationFrameId); // Stop any ongoing animation
            ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas
            ctx.fillStyle = '#000'; // Set background to black
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            ctx.beginPath();
            ctx.strokeStyle = '#fff'; // White color for the snowflake
            ctx.lineWidth = 1;

            // Starting points for a triangle
            const p1 = { x: canvasWidth * 0.1 + translateX * globalScale, y: canvasHeight * 0.75 + translateY * globalScale };
            const p2 = { x: canvasWidth * 0.9 + translateX * globalScale, y: canvasHeight * 0.75 + translateY * globalScale };
            const p3 = { x: canvasWidth * 0.5 + translateX * globalScale, y: canvasHeight * 0.75 - (canvasWidth * 0.8 * Math.sqrt(3)/2) + translateY * globalScale }; // Equilateral triangle

            // Draw the three sides
            drawKochLine(p1, p2, kochGenerations);
            drawKochLine(p2, p3, kochGenerations);
            drawKochLine(p3, p1, kochGenerations);

            ctx.stroke();
        }

        function drawKochLine(p1, p2, generations) {
            if (generations === 0) {
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
            } else {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;

                const pA = { x: p1.x + dx / 3, y: p1.y + dy / 3 };
                const pC = { x: p1.x + dx * 2 / 3, y: p1.y + dy * 2 / 3 };

                // Calculate point pB (peak of the triangle)
                const angle = Math.atan2(dy, dx);
                const len = Math.sqrt(dx * dx + dy * dy) / 3;
                const pB = {
                    x: pA.x + len * Math.cos(angle - Math.PI / 3), // -60 degrees
                    y: pA.y + len * Math.sin(angle - Math.PI / 3)
                };

                // Recursively draw the four segments
                drawKochLine(p1, pA, generations - 1);
                drawKochLine(pA, pB, generations - 1);
                drawKochLine(pB, pC, generations - 1);
                drawKochLine(pC, p2, generations - 1);
            }
        }


        function resetFern() {
            fernPoints = [];
            fernCurrentX = 0;
            fernCurrentY = 0;
            fernTotalPoints = 0;
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
             ctx.fillStyle = '#000'; // Set background to black
             ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        function drawFern() {
             cancelAnimationFrame(animationFrameId); // Stop any ongoing animation
             if (!fernAnimating) {
                 resetFern();
                 // Draw all points at once if not animating
                 while(fernTotalPoints < fernMaxPoints) {
                     generateFernPoint();
                 }
                 renderFernPoints(fernPoints.length); // Render all points
             } else {
                // Animation is handled by animateFern
             }
        }

        function generateFernPoint() {
             // Barnsley Fern transformations
             // Probabilities: 0.01 (stem), 0.85 (successive), 0.07 (left leaflet), 0.07 (right leaflet)
             const r = Math.random();
             let nextX, nextY;

             if (r < 0.01) { // Stem
                 nextX = 0;
                 nextY = 0.16 * fernCurrentY;
             } else if (r < 0.86) { // Successive
                 nextX = 0.85 * fernCurrentX + 0.04 * fernCurrentY;
                 nextY = -0.04 * fernCurrentX + 0.85 * fernCurrentY + 1.6;
             } else if (r < 0.93) { // Left leaflet
                 nextX = 0.20 * fernCurrentX - 0.26 * fernCurrentY;
                 nextY = 0.23 * fernCurrentX + 0.22 * fernCurrentY + 1.6;
             } else { // Right leaflet
                 nextX = -0.15 * fernCurrentX + 0.28 * fernCurrentY;
                 nextY = 0.26 * fernCurrentX + 0.24 * fernCurrentY + 0.44;
             }

             fernCurrentX = nextX;
             fernCurrentY = nextY;

             // Map fern coordinates (-2.18 to 2.65 for x, 0 to 9.99 for y) to canvas coordinates
             // Apply global scale and translation
             const mappedX = (fernCurrentX * globalScale + translateX) * (canvasWidth / 6) + canvasWidth / 2; // Approx range -3 to 3 -> map to 0 to canvasWidth
             const mappedY = canvasHeight - ((fernCurrentY * globalScale + translateY) * (canvasHeight / 10) + canvasHeight / 10); // Approx range 0 to 10 -> map to canvasHeight to 0

             fernPoints.push({x: mappedX, y: mappedY});
             fernTotalPoints++;
        }

        function renderFernPoints(count) {
            ctx.fillStyle = '#0f0'; // Green color for the fern
            // Draw the specified number of points
             for (let i = fernPoints.length - count; i < fernPoints.length; i++) {
                 if (i >= 0) {
                    const p = fernPoints[i];
                    ctx.fillRect(p.x, p.y, 1, 1); // Draw a 1x1 pixel point
                 }
             }
        }

        function animateFern() {
            if (!fernAnimating || fernTotalPoints >= fernMaxPoints) {
                fernAnimating = false;
                 document.getElementById('fernAnimateBtn').textContent = 'Start Animation';
                return;
            }

            // Generate a batch of points
            for(let i = 0; i < fernIterationsPerFrame; i++) {
                if (fernTotalPoints < fernMaxPoints) {
                    generateFernPoint();
                } else {
                    break; // Stop if max points reached during batch generation
                }
            }

            // Render the newly generated points
            renderFernPoints(fernIterationsPerFrame);

            animationFrameId = requestAnimationFrame(animateFern);
        }

        function resetSierpinski() {
            sierpinskiPoints = [];
            sierpinskiCurrentPoint = {x: 0.25, y: 0.25}; // Starting point inside the triangle
            sierpinskiTotalPoints = 0;
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
             ctx.fillStyle = '#000'; // Set background to black
             ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        }


        function drawSierpinski() {
             cancelAnimationFrame(animationFrameId); // Stop any ongoing animation
             if (!sierpinskiAnimating) {
                 resetSierpinski();
                 // Draw all points at once if not animating
                 while(sierpinskiTotalPoints < sierpinskiMaxPoints) {
                     generateSierpinskiPoint();
                 }
                 renderSierpinskiPoints(sierpinskiPoints.length); // Render all points
             } else {
                // Animation is handled by animateSierpinski
             }
        }

        function generateSierpinskiPoint() {
            // Chaos Game: Pick a random vertex and move halfway from the current point towards it.
            const randomIndex = Math.floor(Math.random() * sierpinskiVertices.length);
            const targetVertex = sierpinskiVertices[randomIndex];

            sierpinskiCurrentPoint.x = (sierpinskiCurrentPoint.x + targetVertex.x) / 2;
            sierpinskiCurrentPoint.y = (sierpinskiCurrentPoint.y + targetVertex.y) / 2;

            // Map Sierpinski coordinates (0 to 1 for x, 0 to sqrt(3)/2 for y) to canvas coordinates
            // Apply global scale and translation
            const mappedPoint = mapSierpinskiToCanvas(sierpinskiCurrentPoint.x, sierpinskiCurrentPoint.y);

            sierpinskiPoints.push(mappedPoint);
            sierpinskiTotalPoints++;
        }

        function mapSierpinskiToCanvas(x, y) {
            // Scale and translate to fit the canvas, applying global scale and translation
            const mappedX = (x * globalScale + translateX) * canvasWidth * 0.8 + canvasWidth * 0.1; // Map 0-1 range to 10%-90% of canvas width
            const mappedY = canvasHeight - ((y * globalScale + translateY) * canvasHeight * 0.8 + canvasHeight * 0.1); // Map 0-sqrt(3)/2 range to 90%-10% of canvas height (inverted y)
            return { x: mappedX, y: mappedY };
        }


        function renderSierpinskiPoints(count) {
             ctx.fillStyle = '#fff'; // White color for Sierpinski
             // Draw the specified number of points
             for (let i = sierpinskiPoints.length - count; i < sierpinskiPoints.length; i++) {
                 if (i >= 0) {
                    const p = sierpinskiPoints[i];
                    ctx.fillRect(p.x, p.y, 1, 1); // Draw a 1x1 pixel point
                 }
             }
        }

        function animateSierpinski() {
             if (!sierpinskiAnimating || sierpinskiTotalPoints >= sierpinskiMaxPoints) {
                 sierpinskiAnimating = false;
                 document.getElementById('sierpinskiAnimateBtn').textContent = 'Start Animation';
                 return;
             }

             // Generate a batch of points
             for(let i = 0; i < sierpinskiIterationsPerFrame; i++) {
                 if (sierpinskiTotalPoints < sierpinskiMaxPoints) {
                     generateSierpinskiPoint();
                 } else {
                     break; // Stop if max points reached
                 }
             }

             // Render the newly generated points
             renderSierpinskiPoints(sierpinskiIterationsPerFrame);

             animationFrameId = requestAnimationFrame(animateSierpinski);
        }

        function generateLSystemString(fractalType) {
            let axiom, rules, generations;
            if (fractalType === 'hilbert') {
                axiom = hilbertAxiom;
                rules = hilbertRules;
                generations = hilbertGenerations;
                hilbertString = axiom;
            } else if (fractalType === 'dragon') {
                 axiom = dragonAxiom;
                 rules = dragonRules;
                 generations = dragonGenerations;
                 dragonString = axiom;
            } else { // Assuming L-System Plant
                 axiom = lsystemAxiom;
                 rules = lsystemRules;
                 generations = lsystemGenerations;
                 lsystemString = axiom;
            }


            let currentString = axiom;
            for (let i = 0; i < generations; i++) {
                let nextString = "";
                for (let j = 0; j < currentString.length; j++) {
                    const char = currentString[j];
                    nextString += rules[char] || char;
                }
                currentString = nextString;
            }

            if (fractalType === 'hilbert') {
                 hilbertString = currentString;
                 console.log("Generated Hilbert String:", hilbertString);
            } else if (fractalType === 'dragon') {
                 dragonString = currentString;
                 console.log("Generated Dragon String:", dragonString);
            } else {
                 lsystemString = currentString;
                 console.log("Generated L-System Plant String:", lsystemString);
            }
        }

        function drawLSystem(fractalType) {
             cancelAnimationFrame(animationFrameId); // Stop any ongoing animation
             ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas
             ctx.fillStyle = '#000'; // Set background to black
             ctx.fillRect(0, 0, canvasWidth, canvasHeight);

             let animating, animationStep, lsystemString;
             if (fractalType === 'hilbert') {
                 animating = hilbertAnimating;
                 animationStep = hilbertAnimationStep;
                 lsystemString = hilbertString;
             } else if (fractalType === 'dragon') {
                 animating = dragonAnimating;
                 animationStep = dragonAnimationStep;
                 lsystemString = dragonString;
             } else { // L-System Plant
                 animating = lsystemAnimating;
                 animationStep = lsystemAnimationStep;
                 lsystemString = lsystemString; // This is the original lsystemString
             }


             if (!animating) {
                  // Draw the full generated string at once
                  renderLSystem(fractalType, lsystemString.length);
             } else {
                 // Animation is handled by animateLSystem
             }
        }

        function renderLSystem(fractalType, stepsToDraw) {
            ctx.beginPath();
            ctx.strokeStyle = '#0f0'; // Green color for the plant, white for others
            ctx.lineWidth = 1;

            let x, y, angle, lsystemString, lsystemAngle, stepLength;

             if (fractalType === 'hilbert') {
                 ctx.strokeStyle = '#fff'; // White for Hilbert
                 // Start near the top-left for Hilbert, apply global scale/translate
                 x = canvasWidth * 0.1 + translateX * globalScale;
                 y = canvasHeight * 0.1 + translateY * globalScale;
                 angle = 0; // Start pointing right
                 lsystemString = hilbertString;
                 lsystemAngle = hilbertAngle;
                 stepLength = Math.min(canvasWidth, canvasHeight) / (Math.pow(2, hilbertGenerations) -1) * globalScale; // Adjust step based on generations and scale
             } else if (fractalType === 'dragon') {
                 ctx.strokeStyle = '#fff'; // White for Dragon
                 // Start near the left-center for Dragon, apply global scale/translate
                 x = canvasWidth * 0.2 + translateX * globalScale;
                 y = canvasHeight * 0.5 + translateY * globalScale;
                 angle = 0; // Start pointing right
                 lsystemString = dragonString;
                 lsystemAngle = dragonAngle;
                 stepLength = Math.min(canvasWidth, canvasHeight) / Math.pow(2, dragonGenerations / 2) * globalScale * 0.5; // Adjust step
             }
             else { // L-System Plant
                 ctx.strokeStyle = '#0f0'; // Green for Plant
                 // Start at the bottom-middle for Plant, apply global scale/translate
                 x = canvasWidth / 2 + translateX * globalScale;
                 y = canvasHeight + translateY * globalScale;
                 angle = -90; // Start pointing upwards (in degrees)
                 lsystemString = lsystemString; // Original plant string
                 lsystemAngle = lsystemAngle;
                 stepLength = 10 * globalScale; // Initial step length, apply scale
             }


            const stack = []; // For saving and restoring state ([x, y, angle])

            let drawnSteps = 0;

            for (let i = 0; i < lsystemString.length; i++) {
                if (drawnSteps >= stepsToDraw) {
                    break; // Stop drawing if we've reached the animation step limit
                }

                const char = lsystemString[i];
                const angleRad = angle * Math.PI / 180;

                switch (char) {
                    case 'F': // Move forward and draw a line
                    case 'G': // Move forward without drawing (if G is used in rules)
                         // For Hilbert and Dragon, 'F' draws, 'A' and 'B' are ignored
                         if (fractalType === 'hilbert' && (char === 'A' || char === 'B')) {
                             drawnSteps++;
                             break;
                         }
                         if (fractalType === 'dragon' && (char === 'X' || char === 'Y')) {
                             drawnSteps++;
                             break;
                         }

                        const nextX = x + stepLength * Math.cos(angleRad);
                        const nextY = y + stepLength * Math.sin(angleRad);
                        ctx.moveTo(x, y);
                        ctx.lineTo(nextX, nextY);
                        x = nextX;
                        y = nextY;
                        drawnSteps++;
                        break;
                    case '+': // Turn right
                        angle += lsystemAngle;
                        drawnSteps++;
                        break;
                    case '-': // Turn left
                        angle -= lsystemAngle;
                        drawnSteps++;
                        break;
                    case '[': // Push current state onto stack
                        stack.push({ x: x, y: y, angle: angle });
                        drawnSteps++;
                        break;
                    case ']': // Pop state from stack
                        const state = stack.pop();
                        if (state) {
                            x = state.x;
                            y = state.y;
                            angle = state.angle;
                            ctx.moveTo(x, y); // Move without drawing to the restored position
                        }
                        drawnSteps++;
                        break;
                    // Ignore other characters
                    default:
                         drawnSteps++;
                        break;
                }
            }
            ctx.stroke(); // Draw all the segments at once
        }

        function animateLSystem(fractalType) {
            let animating, animationStep, lsystemString, animationStepIncrement;

            if (fractalType === 'hilbert') {
                 animating = hilbertAnimating;
                 animationStep = hilbertAnimationStep;
                 lsystemString = hilbertString;
                 animationStepIncrement = 100; // Adjust speed
            } else if (fractalType === 'dragon') {
                 animating = dragonAnimating;
                 animationStep = dragonAnimationStep;
                 lsystemString = dragonString;
                 animationStepIncrement = 100; // Adjust speed
            } else { // L-System Plant
                 animating = lsystemAnimating;
                 animationStep = lsystemAnimationStep;
                 lsystemString = lsystemString; // Original plant string
                 animationStepIncrement = 50; // Adjust speed
            }


            if (!animating || animationStep > lsystemString.length) {
                 if (fractalType === 'hilbert') hilbertAnimating = false;
                 else if (fractalType === 'dragon') dragonAnimating = false;
                 else lsystemAnimating = false;

                 document.getElementById(`${fractalType}AnimateBtn`).textContent = 'Start Drawing';
                return;
            }

            ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas for each frame
            ctx.fillStyle = '#000'; // Set background to black
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Draw up to the current animation step
            renderLSystem(fractalType, animationStep);

            // Increment the animation step
            if (fractalType === 'hilbert') hilbertAnimationStep += animationStepIncrement;
            else if (fractalType === 'dragon') dragonAnimationStep += animationStepIncrement;
            else lsystemAnimationStep += animationStepIncrement;


            animationFrameId = requestAnimationFrame(() => animateLSystem(fractalType));
        }


        // --- Main Drawing Function ---

        function drawFractal() {
            // Cancel any ongoing animation before drawing a new static frame
            cancelAnimationFrame(animationFrameId);

            // Clear canvas before drawing
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.fillStyle = '#000'; // Set background to black
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);


            // Apply global translation and scale transformation to the context
            // This simplifies drawing functions for line-based fractals
            ctx.save(); // Save the current context state
            // ctx.translate(canvasWidth / 2 + translateX, canvasHeight / 2 + translateY); // Translate to center + pan
            // ctx.scale(globalScale, globalScale); // Apply scale

            // For line fractals, apply transform within the drawing function or adjust starting points/step length
            // Let's apply it within the drawing functions for more control over positioning

            switch (currentFractal) {
                case 'koch':
                    drawKochSnowflake();
                    break;
                case 'fern':
                    drawFern();
                    break;
                case 'sierpinski':
                    drawSierpinski();
                    break;
                case 'hilbert':
                    drawLSystem('hilbert'); // Use the generic L-System drawing for Hilbert
                    break;
                case 'dragon':
                    drawLSystem('dragon'); // Use the generic L-System drawing for Dragon
                    break;
            }

            ctx.restore(); // Restore the context to remove the global transform
        }

        // --- Event Listeners for Pan and Zoom ---

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;

                // Update translation based on pixel movement
                translateX += dx / globalScale; // Adjust translation by inverse scale
                translateY += dy / globalScale;

                dragStartX = e.clientX;
                dragStartY = e.clientY;

                drawFractal(); // Redraw while dragging
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
             isDragging = false;
             canvas.style.cursor = 'grab';
        });


        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); // Prevent default scrolling

            const mouseX = e.clientX - canvas.getBoundingClientRect().left;
            const mouseY = e.clientY - canvas.getBoundingClientRect().top;

            // Calculate the point in "fractal" coordinates before scaling
            const fractalMouseX = (mouseX - canvasWidth / 2 - translateX) / globalScale;
            const fractalMouseY = (mouseY - canvasHeight / 2 - translateY) / globalScale;


            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9; // Zoom in or out
            const oldScale = globalScale;
            globalScale *= zoomFactor;

            // Update translation to keep the point under the mouse the same
            // New mouse position in canvas coords relative to center: (mouseX - canvasWidth/2, mouseY - canvasHeight/2)
            // This point should correspond to the same fractalMouseX, fractalMouseY
            // (mouseX - canvasWidth/2 - newTranslateX) / newScale = fractalMouseX
            // newTranslateX = mouseX - canvasWidth/2 - fractalMouseX * newScale
            translateX = (mouseX - canvasWidth / 2) / globalScale - fractalMouseX;
            translateY = (mouseY - canvasHeight / 2) / globalScale - fractalMouseY;


            drawFractal();
        });

        // Add touch support for pan and zoom
        let touchStartX, touchStartY;
        let initialTranslateX, initialTranslateY;
        let initialScale;
        let lastTouchDistance = -1;
        let initialMidpointX, initialMidpointY;


        canvas.addEventListener('touchstart', (e) => {
             if (e.touches.length === 1) {
                 isDragging = true;
                 touchStartX = e.touches[0].clientX;
                 touchStartY = e.touches[0].clientY;
                 initialTranslateX = translateX;
                 initialTranslateY = translateY;
                 canvas.style.cursor = 'grabbing';
             } else if (e.touches.length === 2) {
                 // Pinch to zoom
                 isDragging = false; // Disable dragging during pinch
                 lastTouchDistance = getTouchDistance(e.touches);
                 initialScale = globalScale;

                 // Calculate initial midpoint of touches in canvas coordinates
                 const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                 const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                 // Calculate initial midpoint in "fractal" coordinates
                 initialMidpointX = (midX - canvasWidth / 2 - translateX) / globalScale;
                 initialMidpointY = (midY - canvasHeight / 2 - translateY) / globalScale;

             }
             e.preventDefault(); // Prevent default touch behavior (like scrolling)
        });

        canvas.addEventListener('touchmove', (e) => {
             if (isDragging && e.touches.length === 1) {
                 const dx = e.touches[0].clientX - touchStartX;
                 const dy = e.touches[0].clientY - touchStartY;

                 // Update translation based on pixel movement and current scale
                 translateX = initialTranslateX + dx / globalScale;
                 translateY = initialTranslateY + dy / globalScale;

                 drawFractal();
             } else if (e.touches.length === 2) {
                 const currentTouchDistance = getTouchDistance(e.touches);
                 if (lastTouchDistance !== -1) {
                     const zoomFactor = currentTouchDistance / lastTouchDistance;
                     globalScale = initialScale * zoomFactor;

                     // Calculate current midpoint of touches in canvas coordinates
                     const currentMidX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                     const currentMidY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                     // Update translation to keep the initial midpoint in fractal coords under the current midpoint in canvas coords
                     translateX = (currentMidX - canvasWidth / 2) / globalScale - initialMidpointX;
                     translateY = (currentMidY - canvasHeight / 2) / globalScale - initialMidpointY;


                     drawFractal();
                 }
                 lastTouchDistance = currentTouchDistance;
             }
             e.preventDefault();
        });

        canvas.addEventListener('touchend', () => {
             isDragging = false;
             lastTouchDistance = -1; // Reset pinch zoom distance
             canvas.style.cursor = 'grab';
        });

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }


        // --- Navigation ---

        navLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const fractalType = link.getAttribute('data-fractal');
                if (fractalType !== currentFractal) {
                    currentFractal = fractalType;
                    // Update active class for navigation links
                    navLinks.forEach(nav => nav.classList.remove('active'));
                    link.classList.add('active');
                    // Show/hide fractal content divs
                    fractalContentDivs.forEach(div => div.classList.remove('active'));
                    document.getElementById(`${fractalType}-content`).classList.add('active');

                    // Reset pan and zoom when switching fractals
                    translateX = 0;
                    translateY = 0;
                    globalScale = 1;
                    lastTouchDistance = -1; // Reset touch zoom

                    // Stop any ongoing animation
                    cancelAnimationFrame(animationFrameId);
                    fernAnimating = false; // Ensure animation flags are reset
                    sierpinskiAnimating = false;
                    hilbertAnimating = false;
                    dragonAnimating = false;

                    // Regenerate L-System strings if needed
                    if (currentFractal === 'hilbert') generateLSystemString('hilbert');
                    if (currentFractal === 'dragon') generateLSystemString('dragon');


                    // Generate and add controls for the new fractal
                    generateControls(currentFractal);

                    // Set canvas size and draw the new fractal
                    setCanvasSize(); // setCanvasSize calls drawFractal()
                }
            });
        });

        // --- Initialization ---

        // Set initial canvas size on load
        setCanvasSize();

        // Add resize listener to update canvas size and redraw
        window.addEventListener('resize', setCanvasSize);

        // Generate controls for the initial fractal
        generateControls(currentFractal);

        // Draw the initial fractal (called by setCanvasSize)
        // drawFractal();

        // Set initial cursor style
        canvas.style.cursor = 'grab';

        // Generate initial L-System strings
        generateLSystemString('hilbert');
        generateLSystemString('dragon');


    </script>

</body>
</html>
