<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Fractals</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for canvas container and controls */
        #canvas-container {
            position: relative;
            width: 100%;
            max-width: 900px; /* Limit max width */
            margin: 20px auto; /* Center the container */
            border-radius: 8px; /* Rounded corners */
            overflow: hidden; /* Hide overflow */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Add shadow */
        }

        canvas {
            display: block; /* Remove extra space below canvas */
            width: 100%;
            height: auto; /* Maintain aspect ratio */
            background-color: #000; /* Black background for fractals */
        }

        .controls {
            padding: 15px;
            background-color: #f3f4f6; /* Light gray background */
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
            display: flex;
            flex-wrap: wrap; /* Allow controls to wrap on small screens */
            gap: 15px; /* Space between controls */
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #374151; /* Dark gray text */
        }

        .control-group input[type="number"],
        .control-group input[type="range"] {
            padding: 8px;
            border: 1px solid #d1d5db; /* Light border */
            border-radius: 4px;
            font-size: 1rem;
        }

        .control-group input[type="range"] {
            width: 150px; /* Fixed width for sliders */
        }

        button {
             padding: 10px 15px;
             background-color: #3b82f6; /* Blue background */
             color: white;
             border: none;
             border-radius: 5px;
             cursor: pointer;
             font-size: 1rem;
             transition: background-color 0.3s ease;
             box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Add shadow */
         }

         button:hover {
             background-color: #2563eb; /* Darker blue on hover */
         }

         /* Hide fractal divs by default */
         .fractal-content {
             display: none;
         }

         /* Show the active fractal div */
         .fractal-content.active {
             display: block;
         }

         /* Navigation styling */
         nav a {
             padding: 10px 15px;
             margin: 0 5px;
             color: #3b82f6; /* Blue text */
             text-decoration: none;
             font-weight: bold;
             border-radius: 5px;
             transition: background-color 0.3s ease;
         }

         nav a:hover {
             background-color: #eff6ff; /* Light blue background on hover */
         }

         nav a.active {
             background-color: #3b82f6;
             color: white;
         }
    </style>
</head>
<body class="bg-gray-100 font-sans leading-normal tracking-normal">

    <header class="bg-white shadow-md py-4">
        <div class="container mx-auto px-6">
            <h1 class="text-2xl font-bold text-center text-gray-800">Interactive Fractals</h1>
        </div>
    </header>

    <nav class="bg-gray-200 py-3 shadow-sm">
        <div class="container mx-auto px-6 flex justify-center">
            <a href="#mandelbrot" class="nav-link active" data-fractal="mandelbrot">Mandelbrot Set</a>
            <a href="#julia" class="nav-link" data-fractal="julia">Julia Set</a>
            <a href="#fern" class="nav-link" data-fractal="fern">Barnsley Fern</a>
            <a href="#sierpinski" class="nav-link" data-fractal="sierpinski">Sierpinski Triangle</a>
            <a href="#lsystem" class="nav-link" data-fractal="lsystem">L-System Plant</a>
        </div>
    </nav>

    <main class="container mx-auto px-6 py-8">

        <div id="canvas-container">
            <canvas id="fractalCanvas"></canvas>
            <div id="controls" class="controls">
                </div>
        </div>

        <div id="mandelbrot-content" class="fractal-content active">
            </div>

        <div id="julia-content" class="fractal-content">
            </div>

        <div id="fern-content" class="fractal-content">
            </div>

        <div id="sierpinski-content" class="fractal-content">
            </div>

        <div id="lsystem-content" class="fractal-content">
            </div>

    </main>

    <footer class="bg-gray-800 text-white text-center py-4 mt-8">
        <p>&copy; 2023 Interactive Fractals</p>
    </footer>

    <script>
        const canvas = document.getElementById('fractalCanvas');
        const ctx = canvas.getContext('2d');
        const controlsDiv = document.getElementById('controls');
        const navLinks = document.querySelectorAll('.nav-link');
        const fractalContentDivs = document.querySelectorAll('.fractal-content');

        let currentFractal = 'mandelbrot'; // Default fractal
        let animationFrameId = null; // To manage animation loops

        // Canvas dimensions (will be set dynamically)
        let canvasWidth;
        let canvasHeight;

        // Pan and Zoom variables
        let offsetX = 0;
        let offsetY = 0;
        let scale = 1;
        let isDragging = false;
        let dragStartX, dragStartY;

        // --- Fractal Specific Parameters ---

        // Mandelbrot/Julia
        let maxIterations = 100;
        let zoomCenterX = 0;
        let zoomCenterY = 0;
        let juliaCr = -0.7;
        let juliaCi = 0.27015;

        // Barnsley Fern
        let fernPoints = [];
        let fernCurrentX = 0;
        let fernCurrentY = 0;
        let fernIterations = 10000; // Number of points to draw per frame
        let fernTotalPoints = 0; // Total points drawn
        let fernMaxPoints = 50000; // Max points for fern
        let fernAnimating = false;

        // Sierpinski Triangle
        let sierpinskiPoints = [];
        let sierpinskiVertices = [{x: 0, y: 0}, {x: 1, y: 0}, {x: 0.5, y: Math.sqrt(3)/2}];
        let sierpinskiCurrentPoint = {x: 0.25, y: 0.25};
        let sierpinskiIterations = 1000; // Number of points to draw per frame
        let sierpinskiTotalPoints = 0;
        let sierpinskiMaxPoints = 50000;
        let sierpinskiAnimating = false;

        // L-System
        let lsystemAxiom = "F";
        let lsystemRules = {"F": "FF+[+F-F-F]-[-F+F+F]"};
        let lsystemAngle = 25; // Angle in degrees
        let lsystemGenerations = 4;
        let lsystemString = lsystemAxiom;
        let lsystemStep = 10; // Initial step length
        let lsystemAnimating = false;
        let lsystemAnimationStep = 0; // Current step in drawing animation

        // --- Helper Functions ---

        // Function to map canvas coordinates to fractal coordinates
        function mapToFractalCoords(x, y) {
            const fractalX = (x / canvasWidth - 0.5) * (4 / scale) - offsetX + zoomCenterX;
            const fractalY = (y / canvasHeight - 0.5) * (4 / scale) - offsetY + zoomCenterY;
            return { x: fractalX, y: fractalY };
        }

        // Function to map fractal coordinates back to canvas coordinates
        function mapToCanvasCoords(fractalX, fractalY) {
             const canvasX = (fractalX - zoomCenterX + offsetX) * scale / 4 * canvasWidth + canvasWidth / 2;
             const canvasY = (fractalY - zoomCenterY + offsetY) * scale / 4 * canvasHeight + canvasHeight / 2;
             return { x: canvasX, y: canvasY };
         }


        // Function to set canvas size and update dimensions
        function setCanvasSize() {
            canvasWidth = canvas.offsetWidth;
            canvasHeight = canvas.offsetHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            // Redraw after resize
            drawFractal();
        }

        // Function to generate controls for a fractal
        function generateControls(fractalType) {
            controlsDiv.innerHTML = ''; // Clear existing controls

            const createControlGroup = (labelText, inputHtml) => {
                const div = document.createElement('div');
                div.className = 'control-group';
                const label = document.createElement('label');
                label.textContent = labelText;
                div.appendChild(label);
                const input = document.createElement('div'); // Use a div to hold the input HTML
                input.innerHTML = inputHtml;
                div.appendChild(input.firstChild); // Append the actual input element
                return div;
            };

            switch (fractalType) {
                case 'mandelbrot':
                    controlsDiv.appendChild(createControlGroup('Max Iterations:', `<input type="number" id="maxIterations" value="${maxIterations}" min="10" max="1000">`));
                    break;
                case 'julia':
                    controlsDiv.appendChild(createControlGroup('Max Iterations:', `<input type="number" id="maxIterations" value="${maxIterations}" min="10" max="1000">`));
                    controlsDiv.appendChild(createControlGroup('C (Real):', `<input type="number" id="juliaCr" value="${juliaCr}" step="0.0001">`));
                    controlsDiv.appendChild(createControlGroup('C (Imaginary):', `<input type="number" id="juliaCi" value="${juliaCi}" step="0.0001">`));
                    break;
                case 'fern':
                    controlsDiv.appendChild(createControlGroup('Max Points:', `<input type="number" id="fernMaxPoints" value="${fernMaxPoints}" min="10000" max="500000">`));
                    const fernAnimateBtn = document.createElement('button');
                    fernAnimateBtn.textContent = fernAnimating ? 'Stop Animation' : 'Start Animation';
                    fernAnimateBtn.id = 'fernAnimateBtn';
                    controlsDiv.appendChild(fernAnimateBtn);
                    break;
                case 'sierpinski':
                    controlsDiv.appendChild(createControlGroup('Max Points:', `<input type="number" id="sierpinskiMaxPoints" value="${sierpinskiMaxPoints}" min="10000" max="500000">`));
                     const sierpinskiAnimateBtn = document.createElement('button');
                     sierpinskiAnimateBtn.textContent = sierpinskiAnimating ? 'Stop Animation' : 'Start Animation';
                     sierpinskiAnimateBtn.id = 'sierpinskiAnimateBtn';
                     controlsDiv.appendChild(sierpinskiAnimateBtn);
                    break;
                case 'lsystem':
                    controlsDiv.appendChild(createControlGroup('Axiom:', `<input type="text" id="lsystemAxiom" value="${lsystemAxiom}">`));
                    controlsDiv.appendChild(createControlGroup('Rules (JSON):', `<input type="text" id="lsystemRules" value='${JSON.stringify(lsystemRules)}'>`));
                    controlsDiv.appendChild(createControlGroup('Angle (Degrees):', `<input type="number" id="lsystemAngle" value="${lsystemAngle}" step="1">`));
                    controlsDiv.appendChild(createControlGroup('Generations:', `<input type="number" id="lsystemGenerations" value="${lsystemGenerations}" min="1" max="10">`));
                    const lsystemGenerateBtn = document.createElement('button');
                    lsystemGenerateBtn.textContent = 'Generate String';
                    lsystemGenerateBtn.id = 'lsystemGenerateBtn';
                    controlsDiv.appendChild(lsystemGenerateBtn);
                    const lsystemAnimateBtn = document.createElement('button');
                    lsystemAnimateBtn.textContent = lsystemAnimating ? 'Stop Drawing' : 'Start Drawing';
                    lsystemAnimateBtn.id = 'lsystemAnimateBtn';
                    controlsDiv.appendChild(lsystemAnimateBtn);
                    break;
            }

            // Add event listeners to the new controls
            addControlEventListeners(fractalType);
        }

        // Function to add event listeners to controls
        function addControlEventListeners(fractalType) {
            switch (fractalType) {
                case 'mandelbrot':
                    document.getElementById('maxIterations').addEventListener('change', (e) => {
                        maxIterations = parseInt(e.target.value);
                        drawFractal();
                    });
                    break;
                case 'julia':
                    document.getElementById('maxIterations').addEventListener('change', (e) => {
                        maxIterations = parseInt(e.target.value);
                        drawFractal();
                    });
                    document.getElementById('juliaCr').addEventListener('change', (e) => {
                        juliaCr = parseFloat(e.target.value);
                        drawFractal();
                    });
                     document.getElementById('juliaCi').addEventListener('change', (e) => {
                        juliaCi = parseFloat(e.target.value);
                        drawFractal();
                    });
                    break;
                case 'fern':
                    document.getElementById('fernMaxPoints').addEventListener('change', (e) => {
                        fernMaxPoints = parseInt(e.target.value);
                        // Reset and redraw if max points changed significantly
                        if (!fernAnimating) {
                             resetFern();
                             drawFractal();
                        }
                    });
                    document.getElementById('fernAnimateBtn').addEventListener('click', () => {
                        fernAnimating = !fernAnimating;
                        document.getElementById('fernAnimateBtn').textContent = fernAnimating ? 'Stop Animation' : 'Start Animation';
                        if (fernAnimating) {
                            resetFern(); // Start animation from scratch
                            animateFern();
                        } else {
                            cancelAnimationFrame(animationFrameId);
                        }
                    });
                    break;
                case 'sierpinski':
                     document.getElementById('sierpinskiMaxPoints').addEventListener('change', (e) => {
                         sierpinskiMaxPoints = parseInt(e.target.value);
                         if (!sierpinskiAnimating) {
                             resetSierpinski();
                             drawFractal();
                         }
                     });
                     document.getElementById('sierpinskiAnimateBtn').addEventListener('click', () => {
                         sierpinskiAnimating = !sierpinskiAnimating;
                         document.getElementById('sierpinskiAnimateBtn').textContent = sierpinskiAnimating ? 'Stop Animation' : 'Start Animation';
                         if (sierpinskiAnimating) {
                             resetSierpinski();
                             animateSierpinski();
                         } else {
                             cancelAnimationFrame(animationFrameId);
                         }
                     });
                    break;
                case 'lsystem':
                    document.getElementById('lsystemAxiom').addEventListener('change', (e) => {
                        lsystemAxiom = e.target.value;
                        lsystemString = lsystemAxiom; // Reset string
                        lsystemAnimationStep = 0; // Reset animation
                    });
                    document.getElementById('lsystemRules').addEventListener('change', (e) => {
                         try {
                             lsystemRules = JSON.parse(e.target.value);
                             lsystemString = lsystemAxiom; // Reset string
                             lsystemAnimationStep = 0; // Reset animation
                         } catch (error) {
                             console.error("Invalid JSON for L-System rules:", error);
                             alert("Invalid JSON format for rules. Please use valid JSON.");
                         }
                    });
                    document.getElementById('lsystemAngle').addEventListener('change', (e) => {
                        lsystemAngle = parseFloat(e.target.value);
                        lsystemAnimationStep = 0; // Reset animation
                    });
                    document.getElementById('lsystemGenerations').addEventListener('change', (e) => {
                        lsystemGenerations = parseInt(e.target.value);
                        lsystemString = lsystemAxiom; // Reset string
                        lsystemAnimationStep = 0; // Reset animation
                    });
                    document.getElementById('lsystemGenerateBtn').addEventListener('click', () => {
                        generateLSystemString();
                        lsystemAnimationStep = 0; // Reset animation
                        drawFractal(); // Draw the initial state or full generated string
                    });
                    document.getElementById('lsystemAnimateBtn').addEventListener('click', () => {
                         lsystemAnimating = !lsystemAnimating;
                         document.getElementById('lsystemAnimateBtn').textContent = lsystemAnimating ? 'Stop Drawing' : 'Start Drawing';
                         if (lsystemAnimating) {
                             lsystemAnimationStep = 0; // Start drawing from scratch
                             animateLSystem();
                         } else {
                             cancelAnimationFrame(animationFrameId);
                         }
                    });
                    break;
            }
        }


        // --- Drawing Functions for each Fractal ---

        function drawMandelbrot() {
            cancelAnimationFrame(animationFrameId); // Stop any ongoing animation
            ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas
            ctx.fillStyle = '#000'; // Set background to black
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            const aspectRatio = canvasWidth / canvasHeight;
            const viewWidth = 4 / scale;
            const viewHeight = viewWidth / aspectRatio;
            const xMin = zoomCenterX - viewWidth / 2 - offsetX;
            const yMin = zoomCenterY - viewHeight / 2 - offsetY;
            const xMax = xMin + viewWidth;
            const yMax = yMin + viewHeight;

            const pixelSizeX = (xMax - xMin) / canvasWidth;
            const pixelSizeY = (yMax - yMin) / canvasHeight;

            for (let x = 0; x < canvasWidth; x++) {
                for (let y = 0; y < canvasHeight; y++) {
                    const cReal = xMin + x * pixelSizeX;
                    const cImaginary = yMin + y * pixelSizeY;

                    let zReal = 0;
                    let zImaginary = 0;
                    let iterations = 0;

                    while (zReal * zReal + zImaginary * zImaginary <= 4 && iterations < maxIterations) {
                        const nextZReal = zReal * zReal - zImaginary * zImaginary + cReal;
                        const nextZImaginary = 2 * zReal * zImaginary + cImaginary;
                        zReal = nextZReal;
                        zImaginary = nextZImaginary;
                        iterations++;
                    }

                    if (iterations < maxIterations) {
                        // Color based on the number of iterations
                        const color = `hsl(${iterations % 360}, 100%, ${iterations < maxIterations ? 50 : 0}%)`;
                        ctx.fillStyle = color;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
        }

        function drawJulia() {
            cancelAnimationFrame(animationFrameId); // Stop any ongoing animation
            ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas
            ctx.fillStyle = '#000'; // Set background to black
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            const aspectRatio = canvasWidth / canvasHeight;
            const viewWidth = 4 / scale;
            const viewHeight = viewWidth / aspectRatio;
            const xMin = zoomCenterX - viewWidth / 2 - offsetX;
            const yMin = zoomCenterY - viewHeight / 2 - offsetY;
            const xMax = xMin + viewWidth;
            const yMax = yMin + viewHeight;

            const pixelSizeX = (xMax - xMin) / canvasWidth;
            const pixelSizeY = (yMax - yMin) / canvasHeight;

            for (let x = 0; x < canvasWidth; x++) {
                for (let y = 0; y < canvasHeight; y++) {
                    let zReal = xMin + x * pixelSizeX;
                    let zImaginary = yMin + y * pixelSizeY;
                    let iterations = 0;

                    while (zReal * zReal + zImaginary * zImaginary <= 4 && iterations < maxIterations) {
                        const nextZReal = zReal * zReal - zImaginary * zImaginary + juliaCr;
                        const nextZImaginary = 2 * zReal * zImaginary + juliaCi;
                        zReal = nextZReal;
                        zImaginary = nextZImaginary;
                        iterations++;
                    }

                    if (iterations < maxIterations) {
                         // Color based on the number of iterations
                        const color = `hsl(${iterations % 360}, 100%, ${iterations < maxIterations ? 50 : 0}%)`;
                        ctx.fillStyle = color;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
        }

        function resetFern() {
            fernPoints = [];
            fernCurrentX = 0;
            fernCurrentY = 0;
            fernTotalPoints = 0;
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
             ctx.fillStyle = '#000'; // Set background to black
             ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        function drawFern() {
             cancelAnimationFrame(animationFrameId); // Stop any ongoing animation
             if (!fernAnimating) {
                 resetFern();
                 // Draw all points at once if not animating
                 while(fernTotalPoints < fernMaxPoints) {
                     generateFernPoint();
                 }
                 renderFernPoints();
             } else {
                // Animation is handled by animateFern
             }
        }

        function generateFernPoint() {
             // Barnsley Fern transformations
             // Probabilities: 0.01 (stem), 0.85 (successive), 0.07 (left leaflet), 0.07 (right leaflet)
             const r = Math.random();
             let nextX, nextY;

             if (r < 0.01) { // Stem
                 nextX = 0;
                 nextY = 0.16 * fernCurrentY;
             } else if (r < 0.86) { // Successive
                 nextX = 0.85 * fernCurrentX + 0.04 * fernCurrentY;
                 nextY = -0.04 * fernCurrentX + 0.85 * fernCurrentY + 1.6;
             } else if (r < 0.93) { // Left leaflet
                 nextX = 0.20 * fernCurrentX - 0.26 * fernCurrentY;
                 nextY = 0.23 * fernCurrentX + 0.22 * fernCurrentY + 1.6;
             } else { // Right leaflet
                 nextX = -0.15 * fernCurrentX + 0.28 * fernCurrentY;
                 nextY = 0.26 * fernCurrentX + 0.24 * fernCurrentY + 0.44;
             }

             fernCurrentX = nextX;
             fernCurrentY = nextY;

             // Map fern coordinates (-2.18 to 2.65 for x, 0 to 9.99 for y) to canvas coordinates
             // Adjust mapping based on pan and zoom
             const mappedX = (fernCurrentX * scale + offsetX) * (canvasWidth / 6) + canvasWidth / 2; // Approx range -3 to 3 -> map to 0 to canvasWidth
             const mappedY = canvasHeight - ((fernCurrentY * scale + offsetY) * (canvasHeight / 10) + canvasHeight / 10); // Approx range 0 to 10 -> map to canvasHeight to 0

             fernPoints.push({x: mappedX, y: mappedY});
             fernTotalPoints++;
        }

        function renderFernPoints() {
            ctx.fillStyle = '#0f0'; // Green color for the fern
            // Draw only the new points generated in the last iteration
             for (let i = fernPoints.length - fernIterations; i < fernPoints.length; i++) {
                 if (i >= 0) {
                    const p = fernPoints[i];
                    ctx.fillRect(p.x, p.y, 1, 1); // Draw a 1x1 pixel point
                 }
             }
        }

        function animateFern() {
            if (!fernAnimating || fernTotalPoints >= fernMaxPoints) {
                fernAnimating = false;
                 document.getElementById('fernAnimateBtn').textContent = 'Start Animation';
                return;
            }

            // Generate a batch of points
            for(let i = 0; i < fernIterations; i++) {
                if (fernTotalPoints < fernMaxPoints) {
                    generateFernPoint();
                } else {
                    break; // Stop if max points reached during batch generation
                }
            }

            // Render the newly generated points
            renderFernPoints();

            animationFrameId = requestAnimationFrame(animateFern);
        }

        function resetSierpinski() {
            sierpinskiPoints = [];
            sierpinskiCurrentPoint = {x: 0.25, y: 0.25}; // Starting point inside the triangle
            sierpinskiTotalPoints = 0;
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
             ctx.fillStyle = '#000'; // Set background to black
             ctx.fillRect(0, 0, canvasWidth, canvasHeight);
             // Draw initial vertices (optional, but helps visualize the bounds)
             // ctx.fillStyle = '#fff';
             // sierpinskiVertices.forEach(v => {
             //     const mappedV = mapSierpinskiToCanvas(v.x, v.y);
             //     ctx.fillRect(mappedV.x, mappedV.y, 2, 2);
             // });
        }


        function drawSierpinski() {
             cancelAnimationFrame(animationFrameId); // Stop any ongoing animation
             if (!sierpinskiAnimating) {
                 resetSierpinski();
                 // Draw all points at once if not animating
                 while(sierpinskiTotalPoints < sierpinskiMaxPoints) {
                     generateSierpinskiPoint();
                 }
                 renderSierpinskiPoints();
             } else {
                // Animation is handled by animateSierpinski
             }
        }

        function generateSierpinskiPoint() {
            // Chaos Game: Pick a random vertex and move halfway from the current point towards it.
            const randomIndex = Math.floor(Math.random() * sierpinskiVertices.length);
            const targetVertex = sierpinskiVertices[randomIndex];

            sierpinskiCurrentPoint.x = (sierpinskiCurrentPoint.x + targetVertex.x) / 2;
            sierpinskiCurrentPoint.y = (sierpinskiCurrentPoint.y + targetVertex.y) / 2;

            // Map Sierpinski coordinates (0 to 1 for x, 0 to sqrt(3)/2 for y) to canvas coordinates
            // Adjust mapping based on pan and zoom
            const mappedPoint = mapSierpinskiToCanvas(sierpinskiCurrentPoint.x, sierpinskiCurrentPoint.y);

            sierpinskiPoints.push(mappedPoint);
            sierpinskiTotalPoints++;
        }

        function mapSierpinskiToCanvas(x, y) {
            // Scale and translate to fit the canvas, applying pan and zoom
            const mappedX = (x * scale + offsetX) * canvasWidth * 0.8 + canvasWidth * 0.1; // Map 0-1 range to 10%-90% of canvas width
            const mappedY = canvasHeight - ((y * scale + offsetY) * canvasHeight * 0.8 + canvasHeight * 0.1); // Map 0-sqrt(3)/2 range to 90%-10% of canvas height (inverted y)
            return { x: mappedX, y: mappedY };
        }


        function renderSierpinskiPoints() {
             ctx.fillStyle = '#fff'; // White color for Sierpinski
             // Draw only the new points generated in the last iteration
             for (let i = sierpinskiPoints.length - sierpinskiIterations; i < sierpinskiPoints.length; i++) {
                 if (i >= 0) {
                    const p = sierpinskiPoints[i];
                    ctx.fillRect(p.x, p.y, 1, 1); // Draw a 1x1 pixel point
                 }
             }
        }

        function animateSierpinski() {
             if (!sierpinskiAnimating || sierpinskiTotalPoints >= sierpinskiMaxPoints) {
                 sierpinskiAnimating = false;
                 document.getElementById('sierpinskiAnimateBtn').textContent = 'Start Animation';
                 return;
             }

             // Generate a batch of points
             for(let i = 0; i < sierpinskiIterations; i++) {
                 if (sierpinskiTotalPoints < sierpinskiMaxPoints) {
                     generateSierpinskiPoint();
                 } else {
                     break; // Stop if max points reached
                 }
             }

             // Render the newly generated points
             renderSierpinskiPoints();

             animationFrameId = requestAnimationFrame(animateSierpinski);
        }

        function generateLSystemString() {
            lsystemString = lsystemAxiom;
            for (let i = 0; i < lsystemGenerations; i++) {
                let nextString = "";
                for (let j = 0; j < lsystemString.length; j++) {
                    const char = lsystemString[j];
                    nextString += lsystemRules[char] || char;
                }
                lsystemString = nextString;
            }
             console.log("Generated L-System String:", lsystemString);
        }

        function drawLSystem() {
             cancelAnimationFrame(animationFrameId); // Stop any ongoing animation
             ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas
             ctx.fillStyle = '#000'; // Set background to black
             ctx.fillRect(0, 0, canvasWidth, canvasHeight);

             if (!lsystemAnimating) {
                  // Draw the full generated string at once
                  renderLSystem(lsystemString.length);
             } else {
                 // Animation is handled by animateLSystem
             }
        }

        function renderLSystem(stepsToDraw) {
            ctx.beginPath();
            ctx.strokeStyle = '#0f0'; // Green color for the plant
            ctx.lineWidth = 1;

            // Turtle graphics state
            let x = canvasWidth / 2 + offsetX * scale; // Start in the middle, apply pan/zoom
            let y = canvasHeight + offsetY * scale; // Start at the bottom, apply pan/zoom
            let angle = -90; // Start pointing upwards (in degrees)
            const stack = []; // For saving and restoring state ([x, y, angle])

            let drawnSteps = 0;

            for (let i = 0; i < lsystemString.length; i++) {
                if (drawnSteps >= stepsToDraw) {
                    break; // Stop drawing if we've reached the animation step limit
                }

                const char = lsystemString[i];
                const angleRad = angle * Math.PI / 180;

                switch (char) {
                    case 'F': // Move forward and draw a line
                    case 'G': // Move forward without drawing (if G is used in rules)
                        const nextX = x + lsystemStep * scale * Math.cos(angleRad); // Apply scale
                        const nextY = y + lsystemStep * scale * Math.sin(angleRad); // Apply scale
                        ctx.moveTo(x, y);
                        ctx.lineTo(nextX, nextY);
                        x = nextX;
                        y = nextY;
                        drawnSteps++;
                        break;
                    case '+': // Turn right
                        angle += lsystemAngle;
                        drawnSteps++;
                        break;
                    case '-': // Turn left
                        angle -= lsystemAngle;
                        drawnSteps++;
                        break;
                    case '[': // Push current state onto stack
                        stack.push({ x: x, y: y, angle: angle });
                        drawnSteps++;
                        break;
                    case ']': // Pop state from stack
                        const state = stack.pop();
                        if (state) {
                            x = state.x;
                            y = state.y;
                            angle = state.angle;
                            ctx.moveTo(x, y); // Move without drawing to the restored position
                        }
                        drawnSteps++;
                        break;
                    // Ignore other characters
                    default:
                         drawnSteps++;
                        break;
                }
            }
            ctx.stroke(); // Draw all the segments at once
        }

        function animateLSystem() {
            if (!lsystemAnimating || lsystemAnimationStep > lsystemString.length) {
                lsystemAnimating = false;
                 document.getElementById('lsystemAnimateBtn').textContent = 'Start Drawing';
                return;
            }

            ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas for each frame
            ctx.fillStyle = '#000'; // Set background to black
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Draw up to the current animation step
            renderLSystem(lsystemAnimationStep);

            lsystemAnimationStep += 50; // Increment step size for animation speed (adjust as needed)

            animationFrameId = requestAnimationFrame(animateLSystem);
        }


        // --- Main Drawing Function ---

        function drawFractal() {
            // Cancel any ongoing animation before drawing a new static frame
            cancelAnimationFrame(animationFrameId);

            // Reset pan and zoom for non-Mandelbrot/Julia fractals for simplicity
            // Or implement specific pan/zoom mapping for each
            if (currentFractal !== 'mandelbrot' && currentFractal !== 'julia') {
                 offsetX = 0;
                 offsetY = 0;
                 scale = 1;
                 // Note: For Fern/Sierpinski/L-System, pan/zoom is applied within their mapping functions
            }


            switch (currentFractal) {
                case 'mandelbrot':
                    drawMandelbrot();
                    break;
                case 'julia':
                    drawJulia();
                    break;
                case 'fern':
                    drawFern();
                    break;
                case 'sierpinski':
                    drawSierpinski();
                    break;
                case 'lsystem':
                    drawLSystem();
                    break;
            }
        }

        // --- Event Listeners for Pan and Zoom ---

        canvas.addEventListener('mousedown', (e) => {
            if (currentFractal === 'mandelbrot' || currentFractal === 'julia') {
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging && (currentFractal === 'mandelbrot' || currentFractal === 'julia')) {
                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;

                // Update offset based on pixel movement and current scale
                const viewWidth = 4 / scale;
                const viewHeight = viewWidth * (canvasHeight / canvasWidth); // Maintain aspect ratio
                offsetX -= (dx / canvasWidth) * viewWidth;
                offsetY -= (dy / canvasHeight) * viewHeight;

                dragStartX = e.clientX;
                dragStartY = e.clientY;

                drawFractal(); // Redraw while dragging
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (currentFractal === 'mandelbrot' || currentFractal === 'julia')) {
                isDragging = false;
                canvas.style.cursor = 'grab';
            }
        });

        canvas.addEventListener('mouseleave', () => {
             if (currentFractal === 'mandelbrot' || currentFractal === 'julia')) {
                isDragging = false;
                 canvas.style.cursor = 'grab';
             }
        });


        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); // Prevent default scrolling

            if (currentFractal === 'mandelbrot' || currentFractal === 'julia')) {
                 const mouseX = e.clientX - canvas.getBoundingClientRect().left;
                 const mouseY = e.clientY - canvas.getBoundingClientRect().top;

                 // Get fractal coordinates at the mouse position before zooming
                 const { x: fractalX, y: fractalY } = mapToFractalCoords(mouseX, mouseY);

                 const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9; // Zoom in or out
                 scale *= zoomFactor;

                 // Update offset to keep the mouse position centered after zooming
                 const { x: newFractalX, y: newFractalY } = mapToFractalCoords(mouseX, mouseY);
                 offsetX += newFractalX - fractalX;
                 offsetY += newFractalY - fractalY;

                 drawFractal();
            } else {
                 // Basic scaling for other fractals (adjust step length or mapping)
                 const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                 scale *= zoomFactor; // Apply scale to the global scale variable

                 // For Fern/Sierpinski/L-System, redraw to apply the new scale
                 drawFractal();
            }
        });

        // Add touch support for pan and zoom
        let touchStartX, touchStartY;
        let initialScale;
        let lastTouchDistance = -1;

        canvas.addEventListener('touchstart', (e) => {
             if (e.touches.length === 1 && (currentFractal === 'mandelbrot' || currentFractal === 'julia')) {
                 isDragging = true;
                 touchStartX = e.touches[0].clientX;
                 touchStartY = e.touches[0].clientY;
                 canvas.style.cursor = 'grabbing';
             } else if (e.touches.length === 2) {
                 // Pinch to zoom
                 isDragging = false; // Disable dragging during pinch
                 lastTouchDistance = getTouchDistance(e.touches);
                 initialScale = scale;
             }
             e.preventDefault(); // Prevent default touch behavior (like scrolling)
        });

        canvas.addEventListener('touchmove', (e) => {
             if (isDragging && e.touches.length === 1 && (currentFractal === 'mandelbrot' || currentFractal === 'julia')) {
                 const dx = e.touches[0].clientX - touchStartX;
                 const dy = e.touches[0].clientY - touchStartY;

                 const viewWidth = 4 / scale;
                 const viewHeight = viewWidth * (canvasHeight / canvasWidth);
                 offsetX -= (dx / canvasWidth) * viewWidth;
                 offsetY -= (dy / canvasHeight) * viewHeight;

                 touchStartX = e.touches[0].clientX;
                 touchStartY = e.touches[0].clientY;

                 drawFractal();
             } else if (e.touches.length === 2) {
                 const currentTouchDistance = getTouchDistance(e.touches);
                 if (lastTouchDistance !== -1) {
                     const zoomFactor = currentTouchDistance / lastTouchDistance;
                     scale = initialScale * zoomFactor;

                     // Optional: Center zoom around the midpoint of the touches
                     // This is more complex and might require calculating the midpoint in fractal coords
                     // For simplicity here, we just apply the scale.

                     drawFractal();
                 }
                 lastTouchDistance = currentTouchDistance;
             }
             e.preventDefault();
        });

        canvas.addEventListener('touchend', () => {
             isDragging = false;
             lastTouchDistance = -1; // Reset pinch zoom distance
             canvas.style.cursor = 'grab';
        });

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }


        // --- Navigation ---

        navLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const fractalType = link.getAttribute('data-fractal');
                if (fractalType !== currentFractal) {
                    currentFractal = fractalType;
                    // Update active class for navigation links
                    navLinks.forEach(nav => nav.classList.remove('active'));
                    link.classList.add('active');
                    // Show/hide fractal content divs
                    fractalContentDivs.forEach(div => div.classList.remove('active'));
                    document.getElementById(`${fractalType}-content`).classList.add('active');

                    // Reset pan and zoom when switching fractals
                    offsetX = 0;
                    offsetY = 0;
                    scale = 1;
                    lastTouchDistance = -1; // Reset touch zoom

                    // Stop any ongoing animation
                    cancelAnimationFrame(animationFrameId);
                    fernAnimating = false; // Ensure animation flags are reset
                    sierpinskiAnimating = false;
                    lsystemAnimating = false;


                    // Generate and add controls for the new fractal
                    generateControls(currentFractal);

                    // Set canvas size and draw the new fractal
                    setCanvasSize();
                }
            });
        });

        // --- Initialization ---

        // Set initial canvas size on load
        setCanvasSize();

        // Add resize listener to update canvas size and redraw
        window.addEventListener('resize', setCanvasSize);

        // Generate controls for the initial fractal
        generateControls(currentFractal);

        // Draw the initial fractal
        drawFractal();

        // Set initial cursor style
        canvas.style.cursor = 'grab';

    </script>

</body>
</html>
