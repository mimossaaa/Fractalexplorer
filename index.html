<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Fractals</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for canvas container and controls */
        #canvas-container {
            position: relative;
            width: 100%;
            max-width: 900px; /* Limit max width */
            margin: 20px auto; /* Center the container */
            border-radius: 8px; /* Rounded corners */
            overflow: hidden; /* Hide overflow */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Add shadow */
            background-color: #000; /* Black background for fractals */
        }

        canvas {
            display: block; /* Remove extra space below canvas */
            width: 100%;
            height: 500px; /* Give canvas a fixed height for visibility */
            background-color: #000; /* Black background for fractals */
        }

        .controls {
            padding: 15px;
            background-color: #f3f4f6; /* Light gray background */
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
            display: flex;
            flex-wrap: wrap; /* Allow controls to wrap on small screens */
            gap: 15px; /* Space between controls */
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #374151; /* Dark gray text */
        }

        .control-group input[type="number"],
        .control-group input[type="range"],
        .control-group input[type="text"] {
            padding: 8px;
            border: 1px solid #d1d5db; /* Light border */
            border-radius: 4px;
            font-size: 1rem;
        }

        .control-group input[type="range"] {
            width: 150px; /* Fixed width for sliders */
        }

        button {
             padding: 10px 15px;
             background-color: #3b82f6; /* Blue background */
             color: white;
             border: none;
             border-radius: 5agers: 4;
        let fernLSystemAnimating = false;
        let fernLSystemAnimationStep = 0;
        let fernLSystemString = "";
        let fernLSystemRules = {"X": "F+[[X]-X]-F[-FX]+X", "F": "FF"};
        let fernLSystemAxiom = "X";
        let fernLSystemAngle = 25; // Angle in degrees


        // Sierpinski Triangle (Line Method)
        let sierpinskiGenerations = 4;


        // Hilbert Curve
        let hilbertGenerations = 4;
        let hilbertAnimating = false;
        let hilbertAnimationStep = 0;
        let hilbertString = "";
        let hilbertRules = {"A": "+BF-AFA-FB+", "B": "-AF+BFB+FA-"};
        let hilbertAxiom = "A";
        let hilbertAngle = 90; // Angle in degrees

        // Dragon Curve
        let dragonGenerations = 10;
        let dragonAnimating = false;
        let dragonAnimationStep = 0;
        let dragonString = "";
        let dragonRules = {"X": "X+YF+", "Y": "-FX-Y"};
        let dragonAxiom = "FX";
        let dragonAngle = 90; // Angle in degrees


        // --- Helper Functions ---

        // Function to set canvas size and update dimensions
        function setCanvasSize() {
            canvasWidth = canvas.offsetWidth;
            canvasHeight = canvas.offsetHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            // Redraw after resize
            drawFractal();
        }

        // Function to generate controls for a fractal
        function generateControls(fractalType) {
            controlsDiv.innerHTML = ''; // Clear existing controls

            const createControlGroup = (labelText, inputHtml) => {
                const div = document.createElement('div');
                div.className = 'control-group';
                const label = document.createElement('label');
                label.textContent = labelText;
                div.appendChild(label);
                const input = document.createElement('div'); // Use a div to hold the input HTML
                input.innerHTML = inputHtml;
                div.appendChild(input.firstChild); // Append the actual input element
                return div;
            };

            switch (fractalType) {
                case 'koch':
                    controlsDiv.appendChild(createControlGroup('Generations:', `<input type="number" id="kochGenerations" value="${kochGenerations}" min="1" max="7">`));
                    break;
                case 'fern': // L-System Fern
                     controlsDiv.appendChild(createControlGroup('Generations:', `<input type="number" id="fernLSystemGenerations" value="${fernLSystemGenerations}" min="1" max="7">`));
                     controlsDiv.appendChild(createControlGroup('Angle (Degrees):', `<input type="number" id="fernLSystemAngle" value="${fernLSystemAngle}" step="1">`));
                     const fernAnimateBtn = document.createElement('button');
                     fernAnimateBtn.textContent = fernLSystemAnimating ? 'Stop Drawing' : 'Start Drawing';
                     fernAnimateBtn.id = 'fernLSystemAnimateBtn';
                     controlsDiv.appendChild(fernAnimateBtn);
                    break;
                case 'sierpinski': // Line Method
                     controlsDiv.appendChild(createControlGroup('Generations:', `<input type="number" id="sierpinskiGenerations" value="${sierpinskiGenerations}" min="1" max="10">`));
                    break;
                case 'hilbert': // L-System Hilbert
                    controlsDiv.appendChild(createControlGroup('Generations:', `<input type="number" id="hilbertGenerations" value="${hilbertGenerations}" min="1" max="7">`));
                     const hilbertAnimateBtn = document.createElement('button');
                     hilbertAnimateBtn.textContent = hilbertAnimating ? 'Stop Drawing' : 'Start Drawing';
                     hilbertAnimateBtn.id = 'hilbertAnimateBtn';
                     controlsDiv.appendChild(hilbertAnimateBtn);
                    break;
                case 'dragon': // L-System Dragon
                    controlsDiv.appendChild(createControlGroup('Generations:', `<input type="number" id="dragonGenerations" value="${dragonGenerations}" min="1" max="15">`));
                     const dragonAnimateBtn = document.createElement('button');
                     dragonAnimateBtn.textContent = dragonAnimating ? 'Stop Drawing' : 'Start Drawing';
                     dragonAnimateBtn.id = 'dragonAnimateBtn';
                     controlsDiv.appendChild(dragonAnimateBtn);
                    break;
            }

            // Add event listeners to the new controls
            addControlEventListeners(fractalType);
        }

        // Function to add event listeners to controls
        function addControlEventListeners(fractalType) {
            switch (fractalType) {
                case 'koch':
                    document.getElementById('kochGenerations').addEventListener('change', (e) => {
                        kochGenerations = parseInt(e.target.value);
                        drawFractal();
                    });
                    break;
                case 'fern': // L-System Fern
                    document.getElementById('fernLSystemGenerations').addEventListener('change', (e) => {
                        fernLSystemGenerations = parseInt(e.target.value);
                        generateLSystemString('fern'); // Regenerate string
                        fernLSystemAnimationStep = 0; // Reset animation
                        drawFractal(); // Draw the initial state or full generated string
                    });
                     document.getElementById('fernLSystemAngle').addEventListener('change', (e) => {
                        fernLSystemAngle = parseFloat(e.target.value);
                        fernLSystemAnimationStep = 0; // Reset animation
                        drawFractal();
                    });
                     document.getElementById('fernLSystemAnimateBtn').addEventListener('click', () => {
                         fernLSystemAnimating = !fernLSystemAnimating;
                         document.getElementById('fernLSystemAnimateBtn').textContent = fernLSystemAnimating ? 'Stop Drawing' : 'Start Drawing';
                         if (fernLSystemAnimating) {
                             fernLSystemAnimationStep = 0; // Start drawing from scratch
                             animateLSystem('fern');
                         } else {
                             cancelAnimationFrame(animationFrameId);
                         }
                    });
                    break;
                case 'sierpinski': // Line Method
                     document.getElementById('sierpinskiGenerations').addEventListener('change', (e) => {
                         sierpinskiGenerations = parseInt(e.target.value);
                         drawFractal();
                     });
                    break;
                 case 'hilbert': // L-System Hilbert
                    document.getElementById('hilbertGenerations').addEventListener('change', (e) => {
                        hilbertGenerations = parseInt(e.target.value);
                        generateLSystemString('hilbert'); // Regenerate string
                        hilbertAnimationStep = 0; // Reset animation
                        drawFractal(); // Draw the initial state or full generated string
                    });
                     document.getElementById('hilbertAnimateBtn').addEventListener('click', () => {
                         hilbertAnimating = !hilbertAnimating;
                         document.getElementById('hilbertAnimateBtn').textContent = hilbertAnimating ? 'Stop Drawing' : 'Start Drawing';
                         if (hilbertAnimating) {
                             hilbertAnimationStep = 0; // Start drawing from scratch
                             animateLSystem('hilbert');
                         } else {
                             cancelAnimationFrame(animationFrameId);
                         }
                    });
                    break;
                 case 'dragon': // L-System Dragon
                    document.getElementById('dragonGenerations').addEventListener('change', (e) => {
                        dragonGenerations = parseInt(e.target.value);
                        generateLSystemString('dragon'); // Regenerate string
                        dragonAnimationStep = 0; // Reset animation
                        drawFractal(); // Draw the initial state or full generated string
                    });
                     document.getElementById('dragonAnimateBtn').addEventListener('click', () => {
                         dragonAnimating = !dragonAnimating;
                         document.getElementById('dragonAnimateBtn').textContent = dragonAnimating ? 'Stop Drawing' : 'Start Drawing';
                         if (dragonAnimating) {
                             dragonAnimationStep = 0; // Start drawing from scratch
                             animateLSystem('dragon');
                         } else {
                             cancelAnimationFrame(animationFrameId);
                         }
                    });
                    break;
            }
        }


        // --- Drawing Functions for each Fractal ---

        function drawKochSnowflake() {
            cancelAnimationFrame(animationFrameId); // Stop any ongoing animation
            ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas
            ctx.fillStyle = '#000'; // Set background to black
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            ctx.beginPath();
            ctx.strokeStyle = '#fff'; // White color for the snowflake
            ctx.lineWidth = 1;

            // Starting points for a triangle, adjusted by pan and zoom
            const initialSize = Math.min(canvasWidth, canvasHeight) * 0.8;
            // Apply globalScale and translation to the initial points
            const p1 = { x: canvasWidth / 2 - initialSize / 2 * globalScale + translateX * globalScale, y: canvasHeight / 2 + initialSize * Math.sqrt(3)/4 * globalScale + translateY * globalScale };
            const p2 = { x: canvasWidth / 2 + initialSize / 2 * globalScale + translateX * globalScale, y: canvasHeight / 2 + initialSize * Math.sqrt(3)/4 * globalScale + translateY * globalScale };
            const p3 = { x: canvasWidth / 2 + translateX * globalScale, y: canvasHeight / 2 - initialSize * Math.sqrt(3)/4 * globalScale + translateY * globalScale };


            // Draw the three sides
            drawKochLine(p1, p2, kochGenerations);
            drawKochLine(p2, p3, kochGenerations);
            drawKochLine(p3, p1, kochGenerations);

            ctx.stroke();
        }

        function drawKochLine(p1, p2, generations) {
            if (generations === 0) {
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
            } else {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;

                const pA = { x: p1.x + dx / 3, y: p1.y + dy / 3 };
                const pC = { x: p1.x + dx * 2 / 3, y: p1.y + dy * 2 / 3 };

                // Calculate point pB (peak of the triangle)
                const angle = Math.atan2(dy, dx);
                const len = Math.sqrt(dx * dx + dy * dy) / 3;
                const pB = {
                    x: pA.x + len * Math.cos(angle - Math.PI / 3), // -60 degrees
                    y: pA.y + len * Math.sin(angle - Math.PI / 3)
                };

                // Recursively draw the four segments
                drawKochLine(p1, pA, generations - 1);
                drawKochLine(pA, pB, generations - 1);
                drawKochLine(pB, pC, generations - 1);
                drawKochLine(pC, p2, generations - 1);
            }
        }


        function drawSierpinskiTriangle() {
             cancelAnimationFrame(animationFrameId); // Stop any ongoing animation
             ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas
             ctx.fillStyle = '#000'; // Set background to black
             ctx.fillRect(0, 0, canvasWidth, canvasHeight);

             ctx.beginPath();
             ctx.strokeStyle = '#fff'; // White color for Sierpinski
             ctx.lineWidth = 1;

             // Initial vertices for the outer triangle, adjusted by pan and zoom
             const initialSize = Math.min(canvasWidth, canvasHeight) * 0.8;
             const p1 = { x: canvasWidth / 2 - initialSize / 2 * globalScale + translateX * globalScale, y: canvasHeight / 2 + initialSize * Math.sqrt(3)/4 * globalScale + translateY * globalScale };
             const p2 = { x: canvasWidth / 2 + initialSize / 2 * globalScale + translateX * globalScale, y: canvasHeight / 2 + initialSize * Math.sqrt(3)/4 * globalScale + translateY * globalScale };
             const p3 = { x: canvasWidth / 2 + translateX * globalScale, y: canvasHeight / 2 - initialSize * Math.sqrt(3)/4 * globalScale + translateY * globalScale };


             // Start the recursive drawing
             drawSierpinskiRecursive(p1, p2, p3, sierpinskiGenerations);

             ctx.stroke();
        }

        function drawSierpinskiRecursive(p1, p2, p3, generations) {
            if (generations === 0) {
                // Draw the triangle (optional, can just do nothing at base case)
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(p3.x, p3.y);
                ctx.lineTo(p1.x, p1.y);
            } else {
                // Find midpoints
                const m12 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                const m23 = { x: (p2.x + p3.x) / 2, y: (p2.y + p3.y) / 2 };
                const m31 = { x: (p3.x + p1.x) / 2, y: (p3.y + p1.y) / 2 };

                // Recursively draw the three outer triangles
                drawSierpinskiRecursive(p1, m12, m31, generations - 1);
                drawSierpinskiRecursive(m12, p2, m23, generations - 1);
                drawSierpinskiRecursive(m31, m23, p3, generations - 1);
            }
        }


        function generateLSystemString(fractalType) {
            let axiom, rules, generations;
            if (fractalType === 'koch') { // Koch is handled by recursion, but keeping L-System structure for consistency if needed later
                 return ""; // Koch doesn't use L-System string generation here
            } else if (fractalType === 'fern') { // L-System Fern
                axiom = fernLSystemAxiom;
                rules = fernLSystemRules;
                generations = fernLSystemGenerations;
                fernLSystemString = axiom;
            } else if (fractalType === 'hilbert') { // L-System Hilbert
                axiom = hilbertAxiom;
                rules = hilbertRules;
                generations = hilbertGenerations;
                hilbertString = axiom;
            } else if (fractalType === 'dragon') { // L-System Dragon
                 axiom = dragonAxiom;
                 rules = dragonRules;
                 generations = dragonGenerations;
                 dragonString = axiom;
            } else {
                 console.warn("Generating L-System string for unknown type:", fractalType);
                 return "";
            }

            let currentString = axiom;
            for (let i = 0; i < generations; i++) {
                let nextString = "";
                for (let j = 0; j < currentString.length; j++) {
                    const char = currentString[j];
                    nextString += rules[char] || char;
                }
                currentString = nextString;
            }

            if (fractalType === 'fern') {
                 fernLSystemString = currentString;
                 console.log("Generated Fern L-System String:", fernLSystemString);
            } else if (fractalType === 'hilbert') {
                 hilbertString = currentString;
                 console.log("Generated Hilbert String:", hilbertString);
            } else if (fractalType === 'dragon') {
                 dragonString = currentString;
                 console.log("Generated Dragon String:", dragonString);
            }
        }

        function drawLSystem(fractalType) {
             cancelAnimationFrame(animationFrameId); // Stop any ongoing animation
             ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas
             ctx.fillStyle = '#000'; // Set background to black
             ctx.fillRect(0, 0, canvasWidth, canvasHeight);

             let animating, animationStep, lsystemString;
             if (fractalType === 'fern') { // L-System Fern
                 animating = fernLSystemAnimating;
                 animationStep = fernLSystemAnimationStep;
                 lsystemString = fernLSystemString;
             } else if (fractalType === 'hilbert') { // L-System Hilbert
                 animating = hilbertAnimating;
                 animationStep = hilbertAnimationStep;
                 lsystemString = hilbertString;
             } else if (fractalType === 'dragon') { // L-System Dragon
                 animating = dragonAnimating;
                 animationStep = dragonAnimationStep;
                 lsystemString = dragonString;
             } else { // Should not happen with current navigation
                 console.error("Attempted to draw unknown L-System type:", fractalType);
                 return;
             }


             if (!animating) {
                  // Draw the full generated string at once
                  renderLSystem(fractalType, lsystemString.length);
             } else {
                 // Animation is handled by animateLSystem
             }
        }

        function renderLSystem(fractalType, stepsToDraw) {
            ctx.beginPath();
            ctx.strokeStyle = '#fff'; // Default white color
            ctx.lineWidth = 1;

            let x, y, angle, lsystemString, lsystemAngle, stepLength;

             if (fractalType === 'fern') { // L-System Fern
                 ctx.strokeStyle = '#0f0'; // Green for Fern
                 // Start at the bottom-middle for Fern, adjusted by pan/zoom
                 x = canvasWidth / 2 * globalScale + translateX;
                 y = canvasHeight * globalScale + translateY;
                 angle = -90; // Start pointing upwards (in degrees)
                 lsystemString = fernLSystemString;
                 lsystemAngle = fernLSystemAngle;
                 stepLength = 10 * globalScale; // Initial step length, apply scale
             } else if (fractalType === 'hilbert') { // L-System Hilbert
                 ctx.strokeStyle = '#fff'; // White for Hilbert
                 // Start near the top-left for Hilbert, adjusted by pan/zoom
                 x = canvasWidth * 0.1 * globalScale + translateX;
                 y = canvasHeight * 0.1 * globalScale + translateY;
                 angle = 0; // Start pointing right
                 lsystemString = hilbertString;
                 lsystemAngle = hilbertAngle;
                 stepLength = Math.min(canvasWidth, canvasHeight) / (Math.pow(2, hilbertGenerations) -1) * globalScale; // Adjust step based on generations and scale
             } else if (fractalType === 'dragon') { // L-System Dragon
                 ctx.strokeStyle = '#fff'; // White for Dragon
                 // Start near the left-center for Dragon, adjusted by pan/zoom
                 x = canvasWidth * 0.2 * globalScale + translateX;
                 y = canvasHeight * 0.5 * globalScale + translateY;
                 angle = 0; // Start pointing right
                 lsystemString = dragonString;
                 lsystemAngle = dragonAngle;
                 stepLength = Math.min(canvasWidth, canvasHeight) / Math.pow(2, dragonGenerations / 2) * globalScale * 0.5; // Adjust step
             }
             else { // Should not happen
                  console.error("Attempted to render unknown L-System type:", fractalType);
                  return;
             }


            const stack = []; // For saving and restoring state ([x, y, angle])

            let drawnSteps = 0;

            for (let i = 0; i < lsystemString.length; i++) {
                if (drawnSteps >= stepsToDraw) {
                    break; // Stop drawing if we've reached the animation step limit
                }

                const char = lsystemString[i];
                const angleRad = angle * Math.PI / 180;

                switch (char) {
                    case 'F': // Move forward and draw a line
                    case 'G': // Move forward without drawing (if G is used in rules)
                         // For Hilbert and Dragon, 'F' draws, 'A' and 'B' are ignored
                         if (fractalType === 'hilbert' && (char === 'A' || char === 'B')) {
                             drawnSteps++;
                             break;
                         }
                         if (fractalType === 'dragon' && (char === 'X' || char === 'Y')) {
                             drawnSteps++;
                             break;
                         }
                         // For Fern, 'X' is ignored, 'F' draws
                          if (fractalType === 'fern' && char === 'X') {
                             drawnSteps++;
                             break;
                          }


                        const nextX = x + stepLength * Math.cos(angleRad);
                        const nextY = y + stepLength * Math.sin(angleRad);
                        ctx.moveTo(x, y);
                        ctx.lineTo(nextX, nextY);
                        x = nextX;
                        y = nextY;
                        drawnSteps++;
                        break;
                    case '+': // Turn right
                        angle += lsystemAngle;
                        drawnSteps++;
                        break;
                    case '-': // Turn left
                        angle -= lsystemAngle;
                        drawnSteps++;
                        break;
                    case '[': // Push current state onto stack
                        stack.push({ x: x, y: y, angle: angle });
                        drawnSteps++;
                        break;
                    case ']': // Pop state from stack
                        const state = stack.pop();
                        if (state) {
                            x = state.x;
                            y = state.y;
                            angle = state.angle;
                            ctx.moveTo(x, y); // Move without drawing to the restored position
                        }
                        drawnSteps++;
                        break;
                    // Ignore other characters
                    default:
                         drawnSteps++;
                        break;
                }
            }
            ctx.stroke(); // Draw all the segments at once
        }

        function animateLSystem(fractalType) {
            let animating, animationStep, lsystemString, animationStepIncrement;

            if (fractalType === 'fern') { // L-System Fern
                 animating = fernLSystemAnimating;
                 animationStep = fernLSystemAnimationStep;
                 lsystemString = fernLSystemString;
                 animationStepIncrement = 50; // Adjust speed
            } else if (fractalType === 'hilbert') { // L-System Hilbert
                 animating = hilbertAnimating;
                 animationStep = hilbertAnimationStep;
                 lsystemString = hilbertString;
                 animationStepIncrement = 100; // Adjust speed
            } else if (fractalType === 'dragon') { // L-System Dragon
                 animating = dragonAnimating;
                 animationStep = dragonAnimationStep;
                 lsystemString = dragonString;
                 animationStepIncrement = 100; // Adjust speed
            } else { // Should not happen
                 console.error("Attempted to animate unknown L-System type:", fractalType);
                 return;
            }


            if (!animating || animationStep > lsystemString.length) {
                 if (fractalType === 'fern') fernLSystemAnimating = false;
                 else if (fractalType === 'hilbert') hilbertAnimating = false;
                 else if (fractalType === 'dragon') dragonAnimating = false;

                 document.getElementById(`${fractalType}AnimateBtn`).textContent = 'Start Drawing';
                return;
            }

            ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas for each frame
            ctx.fillStyle = '#000'; // Set background to black
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Draw up to the current animation step
            renderLSystem(fractalType, animationStep);

            // Increment the animation step
            if (fractalType === 'fern') fernLSystemAnimationStep += animationStepIncrement;
            else if (fractalType === 'hilbert') hilbertAnimationStep += animationStepIncrement;
            else if (fractalType === 'dragon') dragonAnimationStep += animationStepIncrement;


            animationFrameId = requestAnimationFrame(() => animateLSystem(fractalType));
        }


        // --- Main Drawing Function ---

        function drawFractal() {
            // Cancel any ongoing animation before drawing a new static frame
            cancelAnimationFrame(animationFrameId);

            // Clear canvas before drawing
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.fillStyle = '#000'; // Set background to black
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);


            // Apply global translation and scale transformation to the context
            // This simplifies drawing functions for line-based fractals
            ctx.save(); // Save the current context state
            // ctx.translate(canvasWidth / 2 + translateX, canvasHeight / 2 + translateY); // Translate to center + pan
            // ctx.scale(globalScale, globalScale); // Apply scale

            // For line fractals, apply transform within the drawing function or adjust starting points/step length
            // Let's apply it within the drawing functions for more control over positioning

            switch (currentFractal) {
                case 'koch':
                    drawKochSnowflake();
                    break;
                case 'fern': // L-System Fern
                    drawLSystem('fern');
                    break;
                case 'sierpinski': // Line Method
                    drawSierpinskiTriangle();
                    break;
                case 'hilbert': // L-System Hilbert
                    drawLSystem('hilbert');
                    break;
                case 'dragon': // L-System Dragon
                    drawLSystem('dragon');
                    break;
            }

            ctx.restore(); // Restore the context to remove the global transform
        }

        // --- Event Listeners for Pan and Zoom ---

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;

                // Update translation based on pixel movement
                translateX += dx / globalScale; // Adjust translation by inverse scale
                translateY += dy / globalScale;

                dragStartX = e.clientX;
                dragStartY = e.clientY;

                drawFractal(); // Redraw while dragging
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
             isDragging = false;
             canvas.style.cursor = 'grab';
        });


        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); // Prevent default scrolling

            const mouseX = e.clientX - canvas.getBoundingClientRect().left;
            const mouseY = e.clientY - canvas.getBoundingClientRect().top;

            // Calculate the point in "fractal" coordinates before scaling
            // Adjusted calculation to use current translateX/Y and globalScale
            const fractalMouseX = (mouseX - canvasWidth / 2) / globalScale - translateX;
            const fractalMouseY = (mouseY - canvasHeight / 2) / globalScale - translateY;


            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9; // Zoom in or out
            const oldScale = globalScale;
            globalScale *= zoomFactor;

            // Update translation to keep the point under the mouse the same
            // newTranslateX = (mouseX - canvasWidth/2) / newScale - fractalMouseX
            translateX = (mouseX - canvasWidth / 2) / globalScale - fractalMouseX;
            translateY = (mouseY - canvasHeight / 2) / globalScale - fractalMouseY;


            drawFractal();
        });

        // Add touch support for pan and zoom
        let touchStartX, touchStartY;
        let initialTranslateX, initialTranslateY;
        let initialScale;
        let lastTouchDistance = -1;
        let initialMidpointX, initialMidpointY;


        canvas.addEventListener('touchstart', (e) => {
             if (e.touches.length === 1) {
                 isDragging = true;
                 touchStartX = e.touches[0].clientX;
                 touchStartY = e.touches[0].clientY;
                 initialTranslateX = translateX;
                 initialTranslateY = translateY;
                 canvas.style.cursor = 'grabbing';
             } else if (e.touches.length === 2) {
                 // Pinch to zoom
                 isDragging = false; // Disable dragging during pinch
                 lastTouchDistance = getTouchDistance(e.touches);
                 initialScale = globalScale;

                 // Calculate initial midpoint of touches in canvas coordinates
                 const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                 const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                 // Calculate initial midpoint in "fractal" coordinates
                 initialMidpointX = (midX - canvasWidth / 2 - translateX) / globalScale;
                 initialMidpointY = (midY - canvasHeight / 2 - translateY) / globalScale;

             }
             e.preventDefault(); // Prevent default touch behavior (like scrolling)
        });

        canvas.addEventListener('touchmove', (e) => {
             if (isDragging && e.touches.length === 1) {
                 const dx = e.touches[0].clientX - touchStartX;
                 const dy = e.touches[0].clientY - touchStartY;

                 // Update translation based on pixel movement and current scale
                 translateX = initialTranslateX + dx / globalScale;
                 translateY = initialTranslateY + dy / globalScale;

                 drawFractal();
             } else if (e.touches.length === 2) {
                 const currentTouchDistance = getTouchDistance(e.touches);
                 if (lastTouchDistance !== -1) {
                     const zoomFactor = currentTouchDistance / lastTouchDistance;
                     globalScale = initialScale * zoomFactor;

                     // Calculate current midpoint of touches in canvas coordinates
                     const currentMidX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                     const currentMidY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                     // Update translation to keep the initial midpoint in fractal coords under the current midpoint in canvas coords
                     translateX = (currentMidX - canvasWidth / 2) / globalScale - initialMidpointX;
                     translateY = (currentMidY - canvasHeight / 2) / globalScale - initialMidpointY;


                     drawFractal();
                 }
                 lastTouchDistance = currentTouchDistance;
             }
             e.preventDefault();
        });

        canvas.addEventListener('touchend', () => {
             isDragging = false;
             lastTouchDistance = -1; // Reset pinch zoom distance
             canvas.style.cursor = 'grab';
        });

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // --- Overlay Button Event Listeners ---
        zoomInBtn.addEventListener('click', () => {
            const zoomFactor = 1.2; // Zoom in by 20%
            // Zoom towards the center of the canvas
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;

            const fractalCenterX = (centerX - canvasWidth / 2) / globalScale - translateX;
            const fractalCenterY = (centerY - canvasHeight / 2) / globalScale - translateY;

            globalScale *= zoomFactor;

            translateX = (centerX - canvasWidth / 2) / globalScale - fractalCenterX;
            translateY = (centerY - canvasHeight / 2) / globalScale - fractalCenterY;

            drawFractal();
        });

        zoomOutBtn.addEventListener('click', () => {
            const zoomFactor = 0.8; // Zoom out by 20%
             // Zoom from the center of the canvas
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;

            const fractalCenterX = (centerX - canvasWidth / 2) / globalScale - translateX;
            const fractalCenterY = (centerY - canvasHeight / 2) / globalScale - translateY;

            globalScale *= zoomFactor;

            translateX = (centerX - canvasWidth / 2) / globalScale - fractalCenterX;
            translateY = (centerY - canvasHeight / 2) / globalScale - fractalCenterY;

            drawFractal();
        });

        resetViewBtn.addEventListener('click', () => {
            translateX = 0;
            translateY = 0;
            globalScale = 1;
            drawFractal();
        });


        // --- Navigation ---

        navLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const fractalType = link.getAttribute('data-fractal');
                if (fractalType !== currentFractal) {
                    currentFractal = fractalType;
                    // Update active class for navigation links
                    navLinks.forEach(nav => nav.classList.remove('active'));
                    link.classList.add('active');
                    // Show/hide fractal content divs
                    fractalContentDivs.forEach(div => div.classList.remove('active'));
                    document.getElementById(`${fractalType}-content`).classList.add('active');

                    // Reset pan and zoom when switching fractals
                    translateX = 0;
                    translateY = 0;
                    globalScale = 1;
                    lastTouchDistance = -1; // Reset touch zoom

                    // Stop any ongoing animation
                    cancelAnimationFrame(animationFrameId);
                    // Reset animation flags for L-Systems
                    fernLSystemAnimating = false;
                    hilbertAnimating = false;
                    dragonAnimating = false;


                    // Regenerate L-System strings if needed
                    if (currentFractal === 'fern') generateLSystemString('fern');
                    if (currentFractal === 'hilbert') generateLSystemString('hilbert');
                    if (currentFractal === 'dragon') generateLSystemString('dragon');


                    // Generate and add controls for the new fractal
                    generateControls(currentFractal);

                    // Set canvas size and draw the new fractal
                    setCanvasSize(); // setCanvasSize calls drawFractal()
                }
            });
        });

        // --- Initialization ---

        // Set initial canvas size on load
        setCanvasSize();

        // Add resize listener to update canvas size and redraw
        window.addEventListener('resize', setCanvasSize);

        // Generate controls for the initial fractal
        generateControls(currentFractal);

        // Draw the initial fractal (called by setCanvasSize)
        // drawFractal();

        // Set initial cursor style
        canvas.style.cursor = 'grab';

        // Generate initial L-System strings for applicable fractals
        generateLSystemString('fern');
        generateLSystemString('hilbert');
        generateLSystemString('dragon');


    </script>

</body>
</html>
